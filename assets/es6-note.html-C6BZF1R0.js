import{_ as a,c as o,a as t,o as n}from"./app-D95YKyTd.js";const s={};function p(c,e){return n(),o("div",null,e[0]||(e[0]=[t(`<h1 id="es6学习笔记-持续更新" tabindex="-1"><a class="header-anchor" href="#es6学习笔记-持续更新"><span>ES6学习笔记（持续更新）</span></a></h1><p>let：声明变量，变量作用域在代码块里。这个很好用，直接解决了闭包变量问题。</p><p>let aaa = &#39;aaa&#39; const：声明常量，变量名一般用大写，块级作用域</p><p>const TEST = &#39;aaa&#39;</p><p>ES6允许解构赋值，例如：</p><p>const NAME_LIST = [&#39;aa&#39;, &#39;bbb&#39;, &#39;ccc&#39;]</p><p>let [n1, n2, n3] = NAME_LIST</p><p>const nameList = { name: &#39;aaa&#39;, age: 12, say: function() { console.log(&#39;aaa&#39;) } } let {name, age, sayHello} = nameList sayHello() 模板字符串。内容里可以换行。</p><p>允许大括号里，直接写变量和函数。作为对象的属性和方法。</p><p>let name = &#39;aaa&#39; let change = function(){ console.log(&#39;asdf&#39;) } const test = { name, change, say() { console.log(&#39;bbb&#39;) } } 箭头函数，this始终指向声明时所在作用域的this，不能作为构造函数实例对象，不能使用arguments变量；当形参只有一个，可以省略小括号；当代码体只有一行，可以省略函数体花括号。 let say = (a,b) =&gt; { return a+b } say(1,2) let test = n =&gt; n+1 test(1) const arr = [1,2,3,4,5,6] const result = arr.filter(item=&gt;item %2 ===0) 可以给函数设置初始值。可以跟解构赋值结合</p><p>function add(a,b,c=11) { return a+b+c } let result = add(1,2); function conn({host=&quot;127.0.0.1&quot;, username, passowrd, port}) { console.log(host) } conn({ host: &#39;localhost&#39;, username: &#39;root&#39;, password: &#39;root&#39;, port: 3306 }) rest参数</p><p>function test(...args) { console.log(args) // args是数组 }</p><p>test(&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;) ...扩展运算符可以将数组转换为逗号分隔的“参数序列”</p><p>let test = [&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;] function say() { console.log(arguments) } say(...test)// == say(&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;) 可以用在数组合并</p><p>const arr1 = [111, 222] const arr2 = [222, 333] const result = [...arr1, ...arr2] // == [111, 222, 222, 333]</p><p>// 数组克隆 const arr3 = [&#39;aa&#39;, &#39;bbb&#39;] const arr4 = [..arr3] // [&#39;aa&#39;, &#39;bbb&#39;] Symbol数据类型，值是唯一的，不能运算，</p><p>let s = Symbol() console.log(s) let s2 = Symbol(&#39;name&#39;) 迭代器（iterator接口），for...of便利数组</p><p>const nameList = [&#39;aa&#39;, &#39;bbb&#39;, &#39;ccc&#39;] for(let n of nameLIst) { console.log(n) } 生成器，一个特殊函数，用来异步编程</p><p>function * gen() { console.log(&quot;aaa&quot;) } let iterator = getn() iterator.next() Promise异步编程，Promise是一个构造函数。内部可以进行异步操作，获取成功或失败的结果</p><p>const p = new Promist(function(resolve, reject){ setTimeout(()=&gt;{ resolve(&#39;ok&#39;) }, 1000) }) // 调用 p.then(function(value){ console.log(res) }, function(reason){ console.log(rej) }).then(function(value1){}, function(reason1) {}) Set集合，会自动去重复元素</p><p>const s = new Set([&#39;aa&#39;, &#39;bbb&#39;, &#39;cc&#39;, &#39;aa&#39;]) console.log(s) // aa bbb cc //数组长度 size console.log(s.size) // 添加元素 console.log(s.add(&#39;ddd&#39;)) // 删除 console.log(s.delete(&#39;aa&#39;)) // 是否存在 console.log(s.has(&#39;bbb&#39;)) // 清空 console.log(s.clear())</p><p>Map，键值对。</p><p>const m = new Map() // 设置 m.set(&#39;name&#39;, &#39;aaa&#39;) console.log(m) // 取值 console.log(m.get(&#39;name&#39;)) m.set(&#39;name&#39;, &#39;bbb&#39;) console.log(m) // 删除 m.delete(&#39;name&#39;) console.log(m) class 定义类</p><p>class Phone { static TYPE = &#39;PHONE&#39; constructor(price) { this.price = price } call() { console.log(&#39;calling&#39; + this.price) } }</p><p>const phone = new Phone(111) phone.call() console.log(Phone.TYPE)</p><p>class SmartPhone extends Phone { constructor(brand, price) { super(price) this.brand = brand }</p><pre><code>play() {
    console.log(&#39;play&#39;)
}
</code></pre><p>}</p><p>const smartPhone = new SmartPhone(&#39;huawei&#39;, 9999) smartPhone.play() smartPhone.call() console.log(smartPhone)</p><p>数值扩展</p><p>Number.EPSILON 是javascript表示的最小精度，两个数字相差小于这个数就算相等</p><p>Number.isFinite 检测一个数值是否为有限数</p><p>Number.isNaN 检查一个数是否NaN</p><p>Number.parseInt Number.parseFloat 字符串转整数</p><p>Number.isInteger 判断数字是否为整数</p><p>Math.trunc 将数字的小数部分抹掉</p><p>Math.sign 判断一个数到底为正数 负数 还是零</p><p>Array.prototype.includes 判断数组中是否包含某个元素</p><p>async, await，异步编程。async定义的函数，返回一个promise对象。await必须在async函数内，await右侧必须是一promise对象，await的返回值是promise对象成功的返回值。</p><p>Object.keys获取对象的所有属性名，Object.values</p><p>Object.keys(obj)</p><p>Object.values(obj)</p><p>ES10：字符串 trimStart ，trimEnd清除字符串左右的空格</p><p>ES10：Array.property.flat，把多维数组变成一维数组。</p><p>ES11：私有属性 #</p><p>ES11：可选链操作符?.</p><p>原来的写法：const host = config &amp;&amp; config.db &amp;&amp; config.db.host</p><p>现在的写法：const host = config?.db?.host</p><p>ES11： globalThis 始终指向全局对象</p>`,49)]))}const r=a(s,[["render",p],["__file","es6-note.html.vue"]]),i=JSON.parse(`{"path":"/posts/es6-note.html","title":"ES6学习笔记（持续更新）","lang":"en-US","frontmatter":{"date":"2022-01-11T00:00:00.000Z","category":["技术分享"],"tag":["javascript"]},"headers":[],"git":{"updatedTime":1728706338000,"contributors":[{"name":"test","email":"long275@126.com","commits":1}]},"filePathRelative":"posts/es6-note.md","excerpt":"\\n<p>let：声明变量，变量作用域在代码块里。这个很好用，直接解决了闭包变量问题。</p>\\n<p>let aaa = 'aaa'\\nconst：声明常量，变量名一般用大写，块级作用域</p>\\n<p>const TEST = 'aaa'</p>\\n<p>ES6允许解构赋值，例如：</p>\\n<p>const NAME_LIST = ['aa', 'bbb', 'ccc']</p>\\n<p>let [n1, n2, n3] = NAME_LIST</p>\\n<p>const nameList = {\\nname: 'aaa',\\nage: 12,\\nsay: function() {\\nconsole.log('aaa')\\n}\\n}\\nlet {name, age, sayHello} = nameList\\nsayHello()\\n模板字符串。内容里可以换行。</p>"}`);export{r as comp,i as data};
