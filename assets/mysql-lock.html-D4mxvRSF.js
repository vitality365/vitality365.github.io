import{_ as e,c as o,a as t,o as p}from"./app-C8JjDM0h.js";const r={};function s(c,n){return p(),o("div",null,n[0]||(n[0]=[t(`<h1 id="mysql表锁、行锁、共享锁、排他锁、乐观锁、悲观锁" tabindex="-1"><a class="header-anchor" href="#mysql表锁、行锁、共享锁、排他锁、乐观锁、悲观锁"><span>MySql表锁、行锁、共享锁、排他锁、乐观锁、悲观锁</span></a></h1><p>表锁</p><pre><code>锁住整个表。

开销小，加锁快。

不会死锁(一次性加载所需的所有表)。

锁粒度大，发生锁冲突概率大，并发效率低。

适合查询。
</code></pre><p>行锁</p><pre><code>锁住一行记录。

开销大，加锁慢。

会死锁。

锁粒度小，发生所冲突概率小，并发效率高。

适合并发写，事务控制。

并不是直接丢记录行加锁，而是对行对应的索引加锁：

如果sql 语句操作了主键索引，Mysql 就会锁定这条主键索引。

如果sql语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。

在InnoDB中，如果SQL语句不涉及索引，则会通过隐藏的聚簇索引来对记录加锁。



对聚簇索引加锁，实际效果跟表锁一样，因为找到某一条记录就得扫描全表，要扫描全表，就得锁定表。



MyISAM引擎支持表级锁，不支持行级锁。



InnoDB引擎支持表级锁和行级锁，默认为行级锁。
</code></pre><p>共享锁</p><pre><code>有称之为S锁、读锁。

当前线程对共享资源加共享锁，其他线程可以读取此资源、可以继续追加共享锁，但是不能修改此资源、不能追加排他锁。

语法：select id from t_table in share mode;

多个共享锁可以共存，共享锁与排他锁不能共存。
</code></pre><p>排他锁：</p><pre><code>又称之为X锁、写锁。

当前线程对共享资源加排他锁，其他线程不允许读取此资源，不允许追加共享锁，不允许修改此资源，不允许追加排他锁。

语法：

update t_table set a =1; // 数据库的增删改操作默认都会加排他锁

select * from t_table for update;// for update也是一种增删改

排他锁是独占的，不会与其他锁共存。
</code></pre><p>乐观锁</p><pre><code>乐观地认为，并发问题很难发生。

乐观锁虽然认为并发问题很难发生，但并不是不会发生，所以也会有措施防止问题真的产生：每次数据修改都自增版本号version。

进行数据读取时，并不加锁，而是同时读取当前的版本号version1；在对数据进行修改时，要判断当前的版本号version2是否等于之前的版本号version1。

版本号不匹配，则代表着并发问题已产生，所以需要回滚此次操作。

实现方式：版本号机制、CAS。
</code></pre><p>悲观锁</p><pre><code>悲观锁：悲观地认为，并发问题极易发生。

悲观锁认为并发问题极易发生，所以每次操作，无论读写，都会对记录加锁，以防止其他线程对数据进行修改。

实现方式：数据库的行锁、读锁和写锁。
</code></pre><p>乐观锁与悲观锁是逻辑上的锁，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，都是悲观锁。</p>`,14)]))}const l=e(r,[["render",s],["__file","mysql-lock.html.vue"]]),d=JSON.parse('{"path":"/posts/mysql-lock.html","title":"MySql表锁、行锁、共享锁、排他锁、乐观锁、悲观锁","lang":"en-US","frontmatter":{"date":"2020-12-06T00:00:00.000Z","category":["技术分享"],"tag":["mysql"]},"headers":[],"git":{"updatedTime":1728706338000,"contributors":[{"name":"test","email":"long275@126.com","commits":1}]},"filePathRelative":"posts/mysql-lock.md","excerpt":"\\n<p>表锁</p>\\n<pre><code>锁住整个表。\\n\\n开销小，加锁快。\\n\\n不会死锁(一次性加载所需的所有表)。\\n\\n锁粒度大，发生锁冲突概率大，并发效率低。\\n\\n适合查询。\\n</code></pre>\\n<p>行锁</p>\\n<pre><code>锁住一行记录。\\n\\n开销大，加锁慢。\\n\\n会死锁。\\n\\n锁粒度小，发生所冲突概率小，并发效率高。\\n\\n适合并发写，事务控制。\\n\\n并不是直接丢记录行加锁，而是对行对应的索引加锁：\\n\\n如果sql 语句操作了主键索引，Mysql 就会锁定这条主键索引。\\n\\n如果sql语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。\\n\\n在InnoDB中，如果SQL语句不涉及索引，则会通过隐藏的聚簇索引来对记录加锁。\\n\\n\\n\\n对聚簇索引加锁，实际效果跟表锁一样，因为找到某一条记录就得扫描全表，要扫描全表，就得锁定表。\\n\\n\\n\\nMyISAM引擎支持表级锁，不支持行级锁。\\n\\n\\n\\nInnoDB引擎支持表级锁和行级锁，默认为行级锁。\\n</code></pre>"}');export{l as comp,d as data};
